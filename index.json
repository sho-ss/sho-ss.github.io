[{"authors":["admin"],"categories":null,"content":"とある企業でデータサイエンティストをしています．\n学部生・院生のときは様々な研究テーマを浅く拾ってしまっていたので，向こう数年は一つの領域をしっかり勉強したいと思っています． このブログでは，自分が勉強した内容をまとめていきます．\n","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":-62135596800,"objectID":"598b63dd58b43bce02403646f240cd3c","permalink":"https://sho-ss.github.io/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"author","summary":"とある企業でデータサイエンティストをしています． 学部生・院生のときは様々な研究テーマを浅く拾ってしまっていたので，向こう数年は一つの領域をし","tags":null,"title":"Sho Shimoyama (下山 翔)","type":"author"},{"authors":null,"categories":["GPML"],"content":" 問1 Squared Exponential Kernel を用いたGPの事前分布と事後分布からサンプルした関数をプロットせよ． Squared Exponential Kernelの式は以下で定義される． $$ K(\\mathbf{x}_{p}, \\mathbf{x}_{q}) = \\exp(-\\frac{1}{2} | \\mathbf{x}_{p} - \\mathbf{x}_{q} |^2) $$\nA. import numpy as np from scipy.spatial.distance import cdist import matplotlib.pyplot as plt def squared_exponential(X1, X2): r = cdist(X1, X2) return np.exp( - 0.5 * r**2) def get_posterior_params(X, Xstar, y): print('X: ', X.shape) print('Xstar: ', Xstar.shape) cov_test_train = squared_exponential(Xstar, X) cov_train = squared_exponential(X, X) cov_test = squared_exponential(Xstar, Xstar) cov_inv = np.linalg.inv(cov_train) term1 = np.dot(cov_test_train, cov_inv) mean = np.dot(term1, y) cov = cov_test - np.dot(term1, np.transpose(cov_test_train)) return mean, cov fig = plt.figure(figsize=(15, 6)) ax1 = fig.add_subplot(1, 2, 1) ax2 = fig.add_subplot(1, 2, 2) X = np.linspace(-5, 5, 100) X_t = X.reshape(-1, 1) # prior cov_matrix = squared_exponential(X_t, X_t) Ys = np.random.multivariate_normal(np.zeros(len(cov_matrix)), cov_matrix, size=3) cov = np.diag(cov_matrix) for Y in Ys: ax1.plot(X, Y) mean = np.zeros(len(X)) ax1.fill_between(X, mean+2*cov, mean-2*cov, alpha=.3, color='gray') ax1.set_ylim(-2.3, 2.3) ax1.set_xlim(-5, 5) ax1.set_xlabel('input, x', fontsize=18) ax1.set_ylabel('output, f(x)', fontsize=18) ax1.tick_params(labelsize=18) # posterior X_observed = np.array([-4, -3, -1, 0, 2]).reshape(-1, 1) Y_observed = np.array([-2, 0, 1, 2, -1]).reshape(-1, 1) mean, cov = get_posterior_params(X_observed, X_t, Y_observed) Ys = np.random.multivariate_normal(mean[:, 0], cov, size=3) for Y in Ys: ax2.plot(X, Y) ax2.scatter(X_observed, Y_observed, marker='+', color='black', s=200) cov = np.diag(cov) ax2.fill_between(X, mean[:,0]+2*cov, mean[:,0]-2*cov, alpha=.3, color='gray') ax2.set_ylim(-2.5, 2.5) ax2.set_xlim(-5, 5) ax2.set_xlabel('input, x', fontsize=18) ax2.set_ylabel('output, f(x)', fontsize=18) ax2.tick_params(labelsize=18) plt.savefig('./log/sample.png', dpi=200)  ","date":1553224790,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1553224790,"objectID":"7ecea7702eb7d5e30df4be5feec5d6d6","permalink":"https://sho-ss.github.io/post/gpml/section2/","publishdate":"2019-03-22T12:19:50+09:00","relpermalink":"/post/gpml/section2/","section":"post","summary":"問1 Squared Exponential Kernel を用いたGPの事前分布と事後分布からサンプルした関数をプロットせよ． Squared Exponential Kernelの式は以下で定義される． $$ K(\\mathbf{x}_{p}, \\mathbf{x}_{q}) = \\exp(-\\frac{1}{2} | \\mathbf{x}_{p} - \\mathbf{x}_{q} |^2) $$","tags":["GPML"],"title":"Section2 answer","type":"post"},{"authors":null,"categories":["論文"],"content":" はじめに 論文へのリンク\nモチベーション one-shot architecture searchにおける重み共有について分析したい． 重み共有では構造間で重みを共有して学習を行うが， 様々な構造に対して同一の重み集合を利用してなぜ上手くいくのか．\n概要 モデルはCNNを用いている． 探索空間内の操作を全て含んだone-shotモデルを学習する． これは，重み共有を用いた学習と同じである． ここで操作とは 1$\\times$1conv や 3$\\times$3conv，maxpool などである． 本項ではこれを large one-shot モデルと記す． 学習後の large one-shot モデルから操作のいくつかを取り除き，予測精度の変化を計測する．\n以下の図のように操作を全て含んだモデルを学習する． 先行研究との差 MorphNetはフィルタサイズを対象としている． 一方，提案手法は操作の枝狩りやスキップコネクションに焦点を当てている．\nデータセット CIFAR-10とImageNetを使用．\n結果 weight sharing の役割に対する洞察 構造をサンプリングして，large one-shot モデルから対応する構造を持つモデルを得る． このモデルを単に one-shot モデルと記す． サンプリングした構造を持つ，一から学習したモデルがstand-aloneモデル．\nFigure5は，one-shot モデルと stand-alone モデルの精度の関係を表している． one-shot において精度の高い構造は一から学習しても精度が高くなっており，large one-shot は「構造の良さ」を学習できていると考えられる． また，one-shot における精度差と stand-alone における精度差から，large one-shot は精度への影響が大きい操作の欠落に対して敏感であると思われる．\nこの結果から，「重み共有は操作が性能に与える影響をモデルに識別させる役割がある」と仮定する．\n上述の仮定を示すために，探索空間内のほぼ全ての操作が有効になっている構造 (参照構造) の予測分布と 一部の操作のみが有効になっている構造 (候補構造) の予測分布の間で symmetric KL-divergence を計測する． 論文ではクラス分類を対象としているためモデルの出力は確率分布とみなせる．\nFigure6は，サンプリングした各構造の精度，それらの構造と参照構造との KL-divergence の関係を表している． 精度が高い構造の予測分布は参照構造の予測分布と近しくなることが確認できる． つまり，large one-shot モデルはどの操作が予測性能への影響が大きいかを学習していると考えることができる．\n以上から，重み共有は操作が性能に与える影響をモデルに識別させる役割があると考える．\n  \n手法の性能 Table1 は提案手法 (One-Shot Top, One-Shot Small)と one-shot 学習の枠組みで捉えられる既存手法 (SMASH, ENAS)，ランダムサーチ (Random) それぞれの結果を比較したものである．\nOne-Shot Top はランダムにサンプリングした構造の中で large one-shot において良好な性能を示した上位 10 の構造を用いて， 最初の畳み込み層にサイズ$F$のフィルターを追加して一から学習したモデルである．\nOne-Shot Small はサンプリングした構造の内 large one-shot での精度が閾値を超えた構造の中で最小のパラメータ数を持つ構造を用いて， 最初の畳み込み層にサイズ$F$のフィルターを追加して一から学習したモデルである．\nAll On は全ての操作を含んだ構造を用いて，最初の畳み込み層にサイズ$F$のフィルターを追加して一から学習したモデルである．\nTop，Small と比べると All on は精度差が1%であるが，パラメータ数は大幅に増加している． このことから，architecture search は精度への影響が弱い操作の枝狩りとみなすことができる．\n提案手法は SMASH や Cell search 以外のすべての ENAS 手法と競合している． これは one-shot 学習では hypernet work や controller を必要としないことを示唆している．\n ","date":1552277119,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1552277119,"objectID":"337b56125b2a3c8312ea2753dc9b9f82","permalink":"https://sho-ss.github.io/post/understand_oneshot/my-article-name/","publishdate":"2019-03-11T13:05:19+09:00","relpermalink":"/post/understand_oneshot/my-article-name/","section":"post","summary":"はじめに 論文へのリンク モチベーション one-shot architecture searchにおける重み共有について分析したい． 重み共有では構造間で重みを共有して学習を行うが， 様々","tags":["論文","NAS"],"title":"Understanding and Simplifying One-Shot Architecture Search まとめ","type":"post"}]